# this is a modified PN532 to make it work with 888byte tags
external_components:
  - source: github://luka6000/TagTuner@main
    components: [ pn532 ]
    refresh: 1min

# These substitutions allow the end user to override certain values
substitutions:
  name: "tagtuner"
  friendly_name: "TagTuner"
  d1_mini: d1_mini
  buzpin: D7
  ledpin: D8

esphome:
  name: "${name}"
  friendly_name: ${friendly_name}
  # Automatically add the mac address to the name
  # so you can use a single firmware for all devices
  name_add_mac_suffix: true

  # hello world
  on_boot:
    priority: -100
    then:
    # - light.turn_on:
    #     id: led1
    #     effect: HelloWorld
    - wait_until:
        condition:
          api.connected:
        timeout: 20s
    - text_sensor.template.publish:
        id: status
        state: "Ready"
    # - light.turn_off: led1

esp8266:
  board: $d1_mini
  framework:
    version: recommended

# To be able to get logs from the device via serial and api.
logger:
  # level: VERBOSE
  # level: DEBUG
  # level: WARN
  level: ERROR
  # logs:
  #   light: WARN
    # pn532: DEBUG
    # pn532_i2c: DEBUG

# API is a requirement of the dashboard import.
api:

# OTA is required for Over-the-Air updating
ota:
  platform: esphome

# Sets up the improv via serial client for Wi-Fi provisioning
wifi:
improv_serial:

binary_sensor:
  - platform: template
    name: "=Reading="
    id: txt_reading
    device_class: running
    entity_category: DIAGNOSTIC
    lambda: |-
      if ( !id(pn532_board).is_writing() ) {
        return true;
      } else {
        return false;
      }
  - platform: template
    name: "=Writing="
    id: txt_writing
    device_class: running
    entity_category: DIAGNOSTIC
    lambda: |-
      if ( id(pn532_board).is_writing() ) {
        return true;
      } else {
        return false;
      }

output:
  - platform: esp8266_pwm
    pin: $buzpin
    id: buzzer

rtttl:
  output: buzzer
  id: buz

# light:
#   - platform: neopixelbus
#     id: led1
#     variant: WS2812
#     pin: $ledpin
#     num_leds: 1
#     type: grb
#     restore_mode: ALWAYS_OFF
#     default_transition_length: 0s
#     flash_transition_length: 0s
#     effects:
#       - strobe:
#           name: HelloWorld
#           colors:
#             - state: true
#               brightness: 100%
#               red: 100%
#               green: 0%
#               blue: 0%
#               duration: 250ms
#             - state: true
#               brightness: 100%
#               red: 0%
#               green: 100%
#               blue: 0%
#               duration: 250ms
#             - state: true
#               brightness: 100%
#               red: 0%
#               green: 0%
#               blue: 100%
#               duration: 250ms
#             - state: true
#               brightness: 100%
#               red: 100%
#               green: 100%
#               blue: 100%
#               duration: 250ms
#       - strobe:
#           name: TagWrite
#           colors:
#             - state: true
#               brightness: 100%
#               red: 100%
#               green: 0%
#               blue: 0%
#               duration: 250ms
#             - state: false
#               duration: 50ms

script:
  - id: wait_input
    then:
      - delay: 3s
      - text_sensor.template.publish:
          id: status
          state: "Waiting for input"

  - id: set_tag
    then:
      - text.set:
          id: playlist_uri
          value: !lambda |-
            return id(uri);
      - delay: 10ms
      - text.set:
          id: playlist_artist
          value: !lambda |-
            return id(artist);
      - delay: 10ms
      - text.set:
          id: playlist_info
          value: !lambda |-
            return id(playlist);

  # - id: led_blink
  #   then:
  #   - light.turn_on:
  #       id: led1
  #       brightness: 60%
  #       red: 100%
  #       green: 100%
  #       blue: 100%
  #       flash_length: 100ms
  # - id: led_ok
  #   then:
  #   - light.turn_on:
  #       id: led1
  #       brightness: 100%
  #       red: 0%
  #       green: 100%
  #       blue: 0%
  #       flash_length: 50ms
  #   - delay: 100ms
  #   - light.turn_on:
  #       id: led1
  #       brightness: 100%
  #       red: 0%
  #       green: 100%
  #       blue: 0%
  #       flash_length: 50ms
  # - id: led_success
  #   then:
  #   - light.turn_on:
  #       id: led1
  #       brightness: 100%
  #       red: 0%
  #       green: 100%
  #       blue: 0%
  #       flash_length: 200ms
  #   - delay: 250ms
  #   - light.turn_on:
  #       id: led1
  #       brightness: 100%
  #       red: 0%
  #       green: 100%
  #       blue: 0%
  #       flash_length: 200ms
  #   - delay: 250ms
  #   - light.turn_on:
  #       id: led1
  #       brightness: 100%
  #       red: 0%
  #       green: 100%
  #       blue: 0%
  #       flash_length: 500ms

text:
  - platform: template
    id: playlist_artist
    name: "Playlist artist"
    icon: mdi:account-music
    entity_category: CONFIG
    optimistic: true
    min_length: 0
    max_length: 50
    mode: text
    initial_value: " "
  - platform: template
    id: playlist_info
    name: "Playlist name or album title"
    icon: mdi:playlist-music
    entity_category: CONFIG
    optimistic: true
    min_length: 0
    max_length: 100
    mode: text
    initial_value: " "
  - platform: template
    id: playlist_uri
    name: "Playlist URI"
    icon: mdi:link-variant
    entity_category: CONFIG
    optimistic: true
    min_length: 0
    max_length: 255
    mode: text
    initial_value: " "

text_sensor:
  - platform: template
    id: status
    name: "Status"
    icon: mdi:ladybug
    entity_category: DIAGNOSTIC
    on_value:
      if:
        condition:
          lambda: 'return id(status).state != "Waiting for input";'
        then:
        - script.stop: wait_input
        - script.execute: wait_input

button:
  - platform: restart
    name: "${friendly_name} Restart"
    id: btn_restart
    entity_category: DIAGNOSTIC

  - platform: template
    name: Cancel writing 
    id: btn_cancel_writing
    icon: "mdi:broadcast-off"
    entity_category: CONFIG
    on_press:
      then:
      - lambda: 'id(pn532_board).read_mode();'
      - wait_until:
          timeout: 30s
          condition:
            not:
              pn532.is_writing:
      - delay: 5ms
      - text_sensor.template.publish:
          id: status
          state: "Cancel writing tag"
      # - light.turn_off: led1
      # - script.execute: led_ok

  - platform: template
    name: Erase Tag
    id: btn_erase_tag
    icon: "mdi:nfc-search-variant"
    entity_category: CONFIG    
    on_press:
      then:
      # - light.turn_on:
      #     id: led1
      #     effect: TagWrite
      - text.set:
          id: playlist_artist
          value: ''
      - text.set:
          id: playlist_info
          value: ''
      - text.set:
          id: playlist_uri
          value: ''
      - lambda: 'id(pn532_board).format_mode();'
      - rtttl.play: "write:d=24,o=5,b=100:b"
      - text_sensor.template.publish:
          id: status
          state: "Place tag"
      - wait_until:
          timeout: 30s
          condition:
            not:
              pn532.is_writing:
      - if:
          condition:
            pn532.is_writing:
          then:
          - lambda: 'id(pn532_board).read_mode();'
      - text_sensor.template.publish:
          id: status
          state: "Finished erasing tag"
      - rtttl.play: "write:d=24,o=5,b=100:b,b"
      # - light.turn_off: led1
      # - script.execute: led_success

  - platform: template
    name: Write Tag
    id: btn_write_tag
    icon: "mdi:cast-audio-variant"
    entity_category: CONFIG    
    on_press:
      then:
      # - light.turn_on:
      #     id: led1
      #     effect: TagWrite
      - lambda: |-
          auto message = new nfc::NdefMessage();
          message->add_text_record("TagTuner");
          std::string uri = "";
          std::string artist = "artist/";
          std::string playlist = "playlist/";
          uri += id(playlist_uri).state;
          artist += id(playlist_artist).state;
          playlist += id(playlist_info).state;
          if ( artist != "" ) {
            message->add_text_record(artist);
          }
          if ( playlist != "" ) {
            message->add_text_record(playlist);
          }
          if ( uri != "" ) {
            message->add_uri_record(uri);
          }
          ESP_LOGD("ndef", "Writing payload: %s", uri.c_str());
          id(pn532_board).write_mode(message);
      - rtttl.play: "write:d=24,o=5,b=100:b"
      - text_sensor.template.publish:
          id: status
          state: "Place tag"
      - wait_until:
          timeout: 30s
          condition:
            not:
              pn532.is_writing:
      - if:
          condition:
            pn532.is_writing:
          then:
          - lambda: 'id(pn532_board).read_mode();'
      - logger.log: "Finished writing tag"
      - text_sensor.template.publish:
          id: status
          state: "Finished writing tag"
      - rtttl.play: "write:d=24,o=5,b=100:b,b"
      # - light.turn_off: led1
      # - script.execute: led_success

globals:
  - id: artist
    type: std::string
  - id: playlist
    type: std::string
  - id: uri
    type: std::string

i2c:
  id: bus_i2c
  scan: False
  frequency: 100kHz
  timeout: 13ms #to prevent pn532 timeout

pn532_i2c:
  id: pn532_board
  update_interval: 350ms
  on_tag_removed:
    - logger.log: "on_tag_removed"
    - text_sensor.template.publish:
        id: status
        state: "Tag removed"
    - wait_until:
        condition:
          api.connected:
        timeout: 20s
    - homeassistant.event:
        event: esphome.tagtuner
        data:
          action: "tag_removed"
          uid: !lambda 'return x;'
    # - script.execute: led_blink

  on_tag:
    - logger.log: "on_tag"
    - text_sensor.template.publish:
        id: status
        state: !lambda 'return "Tag "+x;'
    - lambda: |-
        id(playlist)="";
        id(artist)="";
        id(uri)="";
        if (tag.has_ndef_message()) {
          for (auto &record : tag.get_ndef_message()->get_records() ) {
            std::string payload = record->get_payload();
            std::string type = record->get_type();

            if ( payload.substr(0, 7) == "artist/" ) {
              id(artist)=payload.substr(7);
            }
            else if ( payload.substr(0, 9) == "playlist/" ) {
              id(playlist)=payload.substr(9);
            }
            else if (type == "U" && payload.substr(0, 20) != "https://mb.senic.com" ) {
              id(uri)=payload;
            }

          }
        }
    - if:
        condition:
          lambda: 'return id(uri) == "" ;'
        then:
          - text_sensor.template.publish:
              id: status
              state: "Plain UID tag"
          - homeassistant.tag_scanned: !lambda |-
              ESP_LOGD("tagtuner", "No TagTuner NDEF, using UID");
              return x;
        else:
          - wait_until:
              condition:
                api.connected:
              timeout: 20s
          - homeassistant.event:
              event: esphome.tagtuner
              data:
                action: "tag_scanned"
                uid: !lambda 'return x;'
                uri: !lambda 'return id(uri);'
                artist: !lambda 'return id(artist);'
                playlist: !lambda 'return id(playlist);'
          - script.execute: set_tag
    - rtttl.play: "success:d=24,o=5,b=100:c,g,b"
    # - script.execute: led_blink
